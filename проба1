import matplotlib.pyplot as plt
import random

def is_point_in_circumcircle(px, py, ax, ay, bx, by, cx, cy):
    """
    Проверяет, лежит ли точка (px, py) внутри описанной окружности треугольника,
    определяемого точками (ax, ay), (bx, by), (cx, cy).
    """
    matrix = [
        [ax - px, ay - py, (ax - px) ** 2 + (ay - py) ** 2],
        [bx - px, by - py, (bx - px) ** 2 + (by - py) ** 2],
        [cx - px, cy - py, (cx - px) ** 2 + (cy - py) ** 2]
    ]
    determinant = (
        matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[2][1] * matrix[1][2]) -
        matrix[1][0] * (matrix[0][1] * matrix[2][2] - matrix[2][1] * matrix[0][2]) +
        matrix[2][0] * (matrix[0][1] * matrix[1][2] - matrix[1][1] * matrix[0][2])
    )
    return determinant > 0

def flip_edge(triangle1, triangle2, point):
    """
    Выполняет поворот (flip) двух треугольников, образующих общую грань, с добавлением точки.
    """
    a1, b1, c1 = triangle1
    a2, b2, c2 = triangle2

    # Если ребра между треугольниками совпадают, выполняем переворот
    if b1 == b2:
        return [(a1, c2, point), (a2, c1, point)]
    elif a1 == a2:
        return [(b1, c2, point), (b1, c1, point)]
    elif c1 == c2:
        return [(a1, b2, point), (a2, b1, point)]
    return []

def plot_triangulation(points, triangles):
    """Функция для отображения триангуляции."""
    plt.figure(figsize=(8, 8))
    for triangle in triangles:
        x = [triangle[0][0], triangle[1][0], triangle[2][0], triangle[0][0]]
        y = [triangle[0][1], triangle[1][1], triangle[2][1], triangle[0][1]]
        plt.plot(x, y, 'b-', linewidth=1)
    x, y = zip(*points)
    plt.plot(x, y, 'ro', markersize=5)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show()

def triangulate(points):
    """Итеративный алгоритм триангуляции Делоне через повороты (flip)"""
    triangles = []
    # Начинаем с трех произвольных точек, которые точно не попадут в окружность новых точек
    triangles.append([(0, 0), (10, 0), (5, 10)])  # Это начальный треугольник

    for point in points:
        px, py = point
        bad_triangles = []
        edges_to_flip = []

        # Находим все "плохие" треугольники, чья окружность содержит точку
        for triangle in triangles:
            ax, ay = triangle[0]
            bx, by = triangle[1]
            cx, cy = triangle[2]
            
            if is_point_in_circumcircle(px, py, ax, ay, bx, by, cx, cy):
                bad_triangles.append(triangle)
                # Собираем ребра для возможного переворота
                edges_to_flip.append((triangle[0], triangle[1], triangle[2]))

        # Удаляем плохие треугольники
        triangles = [t for t in triangles if t not in bad_triangles]

        # Процесс переворота
        for edge in edges_to_flip:
            triangle1 = edge[:3]
            triangle2 = edge[1:] + (point,)
            new_triangles = flip_edge(triangle1, triangle2, point)
            triangles.extend(new_triangles)  # Добавляем новые треугольники в список

    # Возвращаем финальные треугольники (кроме начального)
    return [t for t in triangles if (0, 0) not in t and (10, 0) not in t and (5, 10) not in t]

# Генерация 10 случайных точек в пределах диапазона от (0, 0) до (10, 10)
if __name__ == "__main__":
    points = [(random.uniform(0, 10), random.uniform(0, 10)) for _ in range(10)]
    print("Points:", points)  # Выводим сгенерированные точки для отладки
    result = triangulate(points)  # Убираем лишнюю 'a'
    plot_triangulation(points, result)
    print("Final Triangles:")
    for triangle in result:
        print("Triangle:", triangle)
